# 屏幕截图归档系统架构文档 (Distributed Screen Archiver)

## 1. 系统边界与交互协议 (Interface Contract)

在两个独立项目之间，必须约定严格的数据交换标准。

### 1.1 数据交换层 (S3 Object Storage)

* **介质**: Cloudflare R2 (兼容 S3 API)
* **对象键名规范 (Key Naming)**:
`v1/{timestamp}_{count}_{uuid}.tar.zst.age`
* `v1`: 版本号，方便未来升级架构时不破坏旧数据。
* `timestamp`: UNIX 时间戳，用于排序和粗略的时间索引。
* `count`: 包内包含的图片数量。
* `uuid`: 随机串，防止时间戳碰撞。


* **数据格式**:
* **容器**: Tar (无压缩归档)
* **压缩**: Zstd (流式压缩)
* **加密**: Age (X25519 混合加密)



### 1.2 信令交互层 (Webhook Protocol)

* **方向**: 插件 (Producer) -> NAS (Consumer)
* **协议**: HTTP/1.1 POST
* **Payload (JSON)**:
```json
{
  "event": "batch_uploaded",
  "version": "1.0",
  "bucket": "my-screenshots",
  "key": "v1/1703750000_50_abcde.tar.zst.age",
  "signature": "hmac_sha256_hash_of_key_with_secret" // 可选：防篡改
}

```



---

## 2. 项目 A: `aw-watcher-screenshot` (插件端)

这是 ActivityWatch 的一个 Watcher，核心职责是采集并安全地“发货”。上传功能作为其中的一个模块 (`mod`) 存在。

### 2.1 文件架构 (Crate Structure)

```text
aw-watcher-screenshot/
├── Cargo.toml
└── src/
    ├── main.rs                 // 入口：初始化 config，启动 capture loop
    ├── settings.rs             // 配置加载 (toml/env)
    ├── capture.rs              // 截图逻辑 (调用 xcap 等库)
    └── storage/                // [核心模块] 负责存储与上传
        ├── mod.rs              // 模块暴露接口
        ├── buffer.rs           // 内存蓄水池 (Accumulator)
        ├── pack.rs             // 处理 Tar + Zstd + Age 加密
        ├── s3.rs               // 负责 R2 API 交互 (PutObject)
        └── webhook.rs          // 负责发送通知 (Fire-and-forget)

```

### 2.2 核心类/结构设计

#### A. 配置模块 (`settings.rs`)

* **Struct: `StorageConfig**`
* 包含 S3 凭证 (`access_key`, `secret_key`, `bucket`, `endpoint`)。
* 包含加密公钥 (`age_public_key`)。
* 包含 Webhook 地址列表 (`primary_url`, `fallback_url`)。



#### B. 存储管理模块 (`storage/buffer.rs`)

* **Struct: `BatchAccumulator**`
* **职责**: 维护一个 `Vec<ScreenshotData>` 和 `last_flush_time`。
* **API**:
* `push(data: ScreenshotData)`: 接收新截图，检查是否满足 `MAX_COUNT` 或 `MAX_TIME`。
* `flush()`: 触发打包上传流程。
* `flush_on_exit()`: **Graceful Shutdown** 专用，确保退出前清空缓冲区。





#### C. 打包与加密模块 (`storage/pack.rs`)

* **Struct: `Packer**`
* **职责**: 将内存中的图片数据转换为加密流。
* **API**:
* `process(images: Vec<ScreenshotData>, pub_key: &str) -> Vec<u8>`
* *内部流水线*: `Images -> TarBuilder -> ZstdEncoder -> AgeEncryptor -> Bytes`





#### D. 上传与通知模块 (`storage/s3.rs` & `webhook.rs`)

* **Struct: `R2Uploader**`
* **职责**: 维护 S3 Client 连接池 (Arc)。
* **API**: `upload_blob(key: &str, data: Vec<u8>)`


* **Struct: `Notifier**`
* **职责**: 上传成功后，尝试向配置的 URL 发送 JSON。支持简单的超时重试，但**不阻塞**主线程。



---

## 3. 项目 B: `nas-archiver-service` (NAS 服务端)

这是一个独立部署在 NAS 上的后台服务（Daemon），可以是 Docker 容器，也可以是 Systemd 服务。它不依赖 ActivityWatch，只依赖 S3 和本地存储。

### 3.1 文件架构 (Crate Structure)

```text
nas-archiver-service/
├── Cargo.toml
├── Dockerfile                  // 独立部署容器化
└── src/
    ├── main.rs                 // 入口：启动 Axum Server 和 Cron 线程
    ├── config.rs               // 配置：R2 凭证、本地存储路径、私钥
    ├── web.rs                  // HTTP 接口层 (接收 Webhook)
    ├── worker.rs               // 业务逻辑层 (下载、解密、归档)
    └── scheduler.rs            // 定时任务层 (兜底扫描)

```

### 3.2 核心类/结构设计

#### A. Web 服务层 (`web.rs`)

* **Framework**: `Axum` 或 `Actix-web`。
* **Handler**: `fn handle_webhook_event()`
* 接收 JSON Payload。
* 校验 Token/Signature。
* 将任务发送给 **TaskQueue** (mpsc channel)，立即返回 `200 OK`，不等待下载完成。



#### B. 工作流引擎 (`worker.rs`)

* **Struct: `ArchiveProcessor**`
* **职责**: 实际干脏活累活的模块。
* **依赖**: 只有这里需要持有 `age_private_key` (私钥)。
* **API**:
* `process_key(key: String)`:
1. `s3.get_object(key)`
2. `age.decrypt(stream)`
3. `zstd.decode(stream)`
4. `tar.unpack(local_path)`
5. `s3.delete_object(key)` -> **原子性闭环**







#### C. 兜底调度器 (`scheduler.rs`)

* **Struct: `Reconciler` (对账员)**
* **职责**: 解决“信令丢失”问题。
* **逻辑**: 使用 `tokio_cron_scheduler` 或简单的 `tokio::time::interval`。
* **API**:
* `run_daily_scan()`: 列出 Bucket 中所有对象，如果是 24 小时前的文件，强制放入 `ArchiveProcessor` 的处理队列。





---

## 4. 部署与运维差异 (Deployment Strategy)

这份设计最大的好处是明确了不同组件的运行环境：

| 维度 | **插件 (Project A)** | **NAS 服务 (Project B)** |
| --- | --- | --- |
| **运行环境** | 用户笔记本 (Windows/Mac/Linux) | 家庭服务器/NAS (Linux/Docker) |
| **网络条件** | 不稳定，多变，依赖 R2 中转 | 稳定，内网环境，宽带下行大 |
| **资源限制** | 内存敏感，CPU 敏感 (不能卡用户) | 资源相对宽裕 |
| **密钥管理** | **仅持有公钥** (Public Key) | **持有私钥** (Private Key) |
| **安全性** | 即使笔记本被黑，历史截图也无法被解密 | 数据保险箱，需重点防护 |

这样一来，你的插件代码（Project A）可以开源（除了配置文件），因为它不包含私钥，也不包含具体的 NAS 部署逻辑，非常符合 ActivityWatch 社区插件的标准。
